SOLID:

block1: 'Нарушение DIP Принцип открытости\закрытости'
\\Проблема здесь заключается в том, что каждый раз, когда добавляется новый тип фигуры (Triangle, Square и др.), 
приходится изменять метод calculateArea() внутри класса AreaCalculator. 
Это противоречит принципу, поскольку модификация существующего метода необходима всякий раз, 
когда появляется новая фигура

block2: 'Нарушение DIP Принцип разделения интерфейсов'
block2: 'Нарушение DIP Принцип подстановки Лисков'
\\Класс Worker включает методы work() и eat(), однако не все наследники нуждаются во всех этих методах одновременно. Например, объект типа Robot не должен иметь обязательный метод eat(), 
потому что робот не нуждается в еде. Этот метод навязывается всем потомкам через родительский класс и создает лишнюю зависимость от методов, которыми некоторые объекты не будут пользоваться вообще
\\Согласно этому принципу, любой подкласс должен корректно заменять своего родителя без потери смысла программы. Однако в данном примере объект класса Robot вынужден переопределять метод eat(), 
хотя физически он не способен есть. Если вызвать метод eat() у объекта Robot, поведение станет некорректным либо приведет к ошибке.

block3: 'Нарушение DIP Принцип единственной ответственности '
\\ Класс Customer сейчас имеет две основные обязанности
 - Размещение заказов (placeOrder)
 - Отправка уведомлений клиентам (sendNotification)
Это нарушение принципа, согласно которому класс должен отвечать только за одну вещь. 
Наличие двух обязанностей делает класс менее гибким и труднее тестируемым, так как любые изменения в одной области могут повлиять на другие.

block4: 'Нарушение DIP '
\\

block5: 'Нарушение DIP '
\\
