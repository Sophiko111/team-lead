SOLID:

block1: 'Нарушение DIP Принцип открытости\закрытости'
\\Проблема здесь заключается в том, что каждый раз, когда добавляется новый тип фигуры (Triangle, Square и др.), 
приходится изменять метод calculateArea() внутри класса AreaCalculator. 
Это противоречит принципу, поскольку модификация существующего метода необходима всякий раз, 
когда появляется новая фигура

block2: 'Нарушение DIP Принцип разделения интерфейсов'
block2: 'Нарушение DIP Принцип подстановки Лисков'
\\Класс Worker включает методы work() и eat(), однако не все наследники нуждаются во всех этих методах одновременно. Например, объект типа Robot не должен иметь обязательный метод eat(), 
потому что робот не нуждается в еде. Этот метод навязывается всем потомкам через родительский класс и создает лишнюю зависимость от методов, которыми некоторые объекты не будут пользоваться вообще
\\Согласно этому принципу, любой подкласс должен корректно заменять своего родителя без потери смысла программы. Однако в данном примере объект класса Robot вынужден переопределять метод eat(), 
хотя физически он не способен есть. Если вызвать метод eat() у объекта Robot, поведение станет некорректным либо приведет к ошибке.

block3: 'Нарушение DIP Принцип единственной ответственности '
\\ Класс Customer сейчас имеет две основные обязанности
 - Размещение заказов (placeOrder)
 - Отправка уведомлений клиентам (sendNotification)
Это нарушение принципа, согласно которому класс должен отвечать только за одну вещь. 
Наличие двух обязанностей делает класс менее гибким и труднее тестируемым, так как любые изменения в одной области могут повлиять на другие.

block4: 'Нарушение DIP Принцип инверсии зависимостей'
\\В коде класс Switch жёстко привязан к конкретной реализации — классу LightBulb. 
Если понадобится заменить лампочку на другой источник света, потребуется изменить реализацию самого переключателя, что нежелательно и усложняет расширение системы.

block5: 'Нарушение DIP Принцип подстановки Лисков'
\\Принцип утверждает, что объекты дочернего класса должны корректно заменять объекты родительского класса без изменения ожидаемого поведения программы. 
В приведённом примере родительский класс Bird предполагает наличие способности к полёту.
Подкласс Penguin наследует эту способность, но фактически пингвин не способен летать.
Из-за такого несоответствия возникает ситуация, когда метод fly() вызывает ошибку для пингвина, хотя остальные птицы могут летать нормально.
